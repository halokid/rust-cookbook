各种设计模式使用的应用场景收集精要
=========================================

为什么是收集精要？不废话，直接就直白场景总结，汇聚本人了解过的使用场景之精要。


### 工厂模式
- 创建一个产品类实例的时候， 什么叫产品类？这个要看具体的业务需求了，举几个例子， 比如订单类、商品类等这些都属于
- 有一个要点就是这个产品实例类不包含其他类的创建过程
关键代码：创建过程在其子类执行。

### 单例模式
- 当某一个内存句柄只需要创建一次， 多个代码逻辑共用这个句柄的时候， 比如数据库连接等
关键代码：构造函数是私有的。

### 建造者模式 
- 当一个类的构造函数有多个参数， 并且参数有些是必须，有些是可选，参数要看具体的逻辑情况而定的情况下，考虑使用构造者模式。
- 当实体构建者类 包含 目标类， 或者是目标类子类的时候
- 抽象构建类方法不应该有任何参数， 方法里面具体的逻辑才调用目标类的方法、定义目标类的方法参数
- 针对实体构建者类的实际赋值过程逻辑通常定义在目标类, 构建者类通常只有构造、new等方法
关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。


### 原型模式
- 重复生成类实例的优化， 每次new一个类时，初始化会需要比较多的资源， 直接用原型模型clone类实例，科优化性能
- 多个类实例有重复的属性、方法， 然后在各种逻辑场景中有可能会修改类实例的数据时
关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口

### 配适器模式 
- 假如有多个不兼容的接口，想统一把这些不兼容的接口封装成统一的出处，也就是搭建一个桥梁，通过这个桥梁可以通往这些不兼容的接口，这个桥梁就是配适器
关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。

### 桥接模式
- 当要把抽象的部分跟实现的部分分离的场景， 因为实现就是单纯的实现， 不管抽象，抽象的话，可以按照具体的业务需求去更改抽象，而不会影响实现
关键代码：抽象类依赖实现类。

### 过滤器模式
- 当需要使用不同的标准来过滤一组对象、数据等，并且需要通过逻辑运算以解耦的方式把它们连接起来。
- 常见的按照某个条件filter组合数据场景


### 组合模式
- 把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象。
- 通常用于树形、链表、多节点组合等数据结构的场景
关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

### 装饰器模式
- 允许向一个现有的对象添加新的功能，同时又不改变其结构, 从逻辑上是作为一个现有类的封装
- 常见的插件式设计就是这种模式， 就是增加一个功能就是多一个plugin，不改变原来的源码结构
- 我们为了而给一个类增加功能, 通常都采用增加子类的形式， 但是功能越来越多，子类会很膨胀，很难管理，在不想增加子类的情况下，扩展原有类的功能也可以采用这种模式
关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

### 外观模式
- 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口
- 为了尽量用对接方简单调用而设计的一种模式, 提供了客户端请求的简化方法和对现有系统类方法的委托调用。
- 这种模式设计的源码结构，可以比较清晰的分析到源码的思路，假如是自己写的代码，日后再分析源码结构时，可以快速了解架构设计的思路
关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。


### 享元模式
- 主要用于减少创建对象的数量，以减少内存占用和提高性能
- 业务场景符合可以重用现有的同类对象
关键代码：用 HashMap 存储这些对象。

### 代理模式
- 一个类代表另一个类的功能, 为其他对象提供一种代理以控制对这个对象的访问。
- 使用场景通常都是 想在访问一个类时做一些控制，然后就搞一个代理类出来代理实际要访问的类
- 这个代理类又叫中间层、代理人等等， 通常是 middleware等单词
- 通过调用proxy类的方法去调用真正的处理逻辑
关键代码：实现与被代理类组合。

### 责任链模式
- 简单来说就是建立一条数据处理链， 处理接收者1搞不定， 就传给接收者2， 再搞不定就传给接收者3， 以此类推
- 数据结构的形式是建立一条处理链， 是链的形式
- 避免请求发送者与接收者耦合在一起
- 责任链处理的接口 跟 实际处理逻辑的实体类 源码是分开的
关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

### 命令模式
- 一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令
- 将"行为请求者"与"行为实现者"解耦
关键代码: 定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口

### 解释器模式
- 构建环境类，包含解释器之外的一些全局信息，一般是 HashMap
- 主要用来评估语言的语法或表达式的作用

### 迭代器模式
- 用于顺序访问集合对象的元素，不需要知道集合对象的底层表示
关键代码：定义接口：hasNext, next。

### 中介者模式
- 是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
何时使用：多个类相互耦合，形成了网状结构
关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。



### 参考
https://www.runoob.com/design-pattern/composite-pattern.html





